<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
  
        .state {
          fill: lightgrey;
        }
        .outline {
          fill: none;
          stroke: black;
          stroke-width: 1px;
        }
        .graticule {
            fill: none;
            stroke: grey;
            stroke-width: 1px;
        }
        .tooltip {
            pointer-events: none;
        }

        .row{
            display: flex;
        }

        #controls {
            padding-top: 50px;
            padding-left: 20px;
        }
    
      </style>
</head>

<body>

  <h1>Find'a Pup!</h1>
  
    <div class="row">
        <svg id="choropleth" height="600" width="900" style="background: #445; margin-top:50px" ></svg>
        <div id="controls"></div>
    </div>
    

<script>
    const svg = d3.select("#choropleth");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left:20};
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
                   .attr("transform","translate("+margin.left+","+margin.top+")");
    const breeds = [];

    // 1. An async function to load data and build the map
    const requestDataMap = async function() {
        // 2. Draw a map of US using topoJSON
        // 2a. Import data as synchronous call to topoJSON data file
        const us = await d3.json("./us-smaller.json");
        console.log(us);
        
        // 2b. Pick out topographic features and build d3 helpers
        var states = topojson.feature(us, us.objects.states);     // List of state outlines to fill
        var statesMesh = topojson.mesh(us, us.objects.states);    // 'Mesh' of all outlines put together for a stroke
        var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
        var path = d3.geoPath().projection(projection);
        console.log(states);
        console.log(statesMesh);

        // 2d. Add a graticule (we did this after 2c, but it must go here)
        //      (Graticules are much more configurable, but we'll use the default for now)
        let graticule = d3.geoGraticule10();
        console.log(graticule);
        map.append("path").attr("class","graticule").attr("d", path(graticule));

        // 2c. Draw states and outlines (see CSS at the top)
        let statePaths = map.selectAll("path.state").data(states.features)
                        .join("path")
                        .attr("class", "state")
                        .attr("note", d => d.id)  // debugging
                        .attr("d", path)
                        // .on('mouseover',  mouseEntersState )
                        // .on('mouseout',  mouseLeavesState );
    
        map.append("path").datum(statesMesh)
        .attr("class","outline")
        .attr("d", path);


        // 3a. Import survey data as synchronous calls
        // "../datasets/state-survey-responses-fa22.csv"
        
        const allDogData = await d3.csv("./allDogDescriptions.csv", d3.autoType);
        console.log('allDogData', allDogData);

        let stateShortCounts = {}; // state_short => count #
        allDogData.forEach( row => {
            if (row.contact_state in stateShortCounts) {
                stateShortCounts[ row.contact_state ] += 1;
            }else{
                stateShortCounts[ row.contact_state ] = 1;
            }
        });

        const surveyData = await d3.csv("./state-survey-responses-fa22.csv", d3.autoType);
        
        let stateIdCounts = {};
        surveyData.forEach( row => {
            stateIdCounts[ row.state_code ] = stateShortCounts[ row.state_short ];
        });
        console.log(stateIdCounts);


        // 3c. Make a d3 color scale for frequency    
        const colorScale = d3.scaleQuantile()      // LLLLLLLLL
                             .domain(Object.values(stateIdCounts))
                             .range(["#D095C7","#AF5675","#9E3841","#651F26","#270A0E"]);

        // 3d. Recolor the states to make a choropleth map
        map.selectAll(".state")
        .style("fill", d => colorScale( stateIdCounts[d.id]) );
      };

    // 1. An async function to load data
    const requestDataSlider = async function() {

        //load dog parameters json
        var data = await d3.json("dog-parameter.json");

        //Pre-process data: we only need data that includes our filter categories:
        //kid friendly, pet friendly, intelligence, and general health
        data = data["dog_breeds"];
        traits = ["Incredibly Kid Friendly Dogs", "Dog Friendly", "Intelligence", "General Health"]
        for (x = 0; x < data.length; x++)
        {
            //if filter does not exist, remove that dog breed from data
            if(traits.indexOf(data[x]) < 0)
               data.splice(x,1);
        }

        //a list of filters the user has applied
        var filters = {};

        //loop through each of the filter functions and apply them
        function pointPassesFilters(point)
        {
            let stillPassed = true;
            
            // Objects.values(filters) is the list of filter functions
            Object.values(filters).forEach( filterFunc => {
                stillPassed = filterFunc(point) && stillPassed;
             });
        
            return stillPassed;
        }
        
        // Updating the map as the user interacts with the interface
        function updateDogs(data)
        {
            //First filter the breeds that pass the users filters
            for (const key in data) 
            {
                if (pointPassesFilters(data[key])){
                  breeds.push(key);
                }     
            };
            console.log(breeds);

            // Then, connect the breeds that are left with all dog data
            // and call update the map

            // updateMap()
        }

        function makeSlider(container, label, attribute, sliderWidth, sliderHeight) {
            // Get a array of values for attribute
            let values = Object.values(data).map(d => d[attribute]);

            // Find the min and max for some values
            let minMax = d3.extent(values);
            let xScale = d3.scaleLinear().domain(minMax).range([10, sliderWidth-10]);
            let xAxis = d3.axisBottom(xScale).tickFormat(d3.format(".2s"));

            let wrapper = container.append("div").attr("class", "control");
            wrapper.append("div").text(label);

            let canvas = wrapper.append("svg").attr("width", sliderWidth)
                                              .attr("height", sliderHeight+20)
                                              .attr("attribute", attribute);
                                              
            let areaLayer = canvas.append("g");
            canvas.append("g").attr("transform", `translate(0,${sliderHeight})`).call(xAxis);

            let numBins = 5;

            let histoGen = d3.histogram().domain(minMax).thresholds(numBins);
            let counts = histoGen(values);

            counts.unshift({ x0:0,
                             x1: counts[0].x0,
                            length: counts[0].length });
            
            let yScale = d3.scaleLinear().domain(d3.extent(counts, d=>d.length))
                                         .range([sliderHeight, 4]);

            let area = d3.area().x(d => xScale(d.x1))
                .y0(yScale(0))
                .y1(d=> yScale(d.length))
                .curve(d3.curveNatural);

            areaLayer.append("path").datum(counts)
                     .attr("class", "area")
                     .attr("d", area);

                
            // Create the filter_function for this slider
            // To be overwritten in brushMoved event
            let filterFunc = d => true;
            // Add filterFunc to the filters dictionary
            filters[attribute] = filterFunc;

            var brush = d3.brushX().extent([[10,0],
                                            [sliderWidth-10,sliderHeight]])
                                    .on("brush end", brushMoved);

            function brushMoved(event)
            {
                if (event.selection !== null) {
                    let start = xScale.invert(event.selection[0]);
                    let end = xScale.invert(event.selection[1]);

                    let filterFunc = d => d[attribute] >= start && d[attribute] <= end;
                    filters[attribute] = filterFunc;

                    updateDogs(data);
                }
                else {
                    let filterFunc = d => true;
                    filters[attribute] = filterFunc;

                    updateDogs(data);
                }
            }

            canvas.append("g").attr("class","brush").call(brush);
        }

        let controls = d3.select("#controls");
        
            //Kid Friendly
            makeSlider( controls, "Incredibly Kid Friendly Dogs: ", "Incredibly Kid Friendly Dogs", 300, 30);

            //Pet Friendly
            makeSlider( controls, "Dog Friendly Dogs: ", "Dog Friendly", 300, 30);

            //Intelligence
            makeSlider( controls, "Intelligence: ", "Intelligence", 300, 30);

            //General Health
            makeSlider( controls, "General Health: ", "General Health", 300, 30);
        };
    
        
    //call async function
    requestDataMap();
    requestDataSlider();


</script>

</body>
</html>
